# 2.4 可变数据

我们已经看到了抽象在帮助我们应对大型系统的复杂性方面是如何至关重要的。 有效的程序设计还需要有组织的原则来指导我们制定程序的总体设计。 特别是，我们需要一些策略来帮助我们将大型系统结构成模块化的，这意味着它们自然地划分为可以单独开发和维护的连贯部分。 

创建模块化程序的一种强大技术是合并可能随时间改变状态的数据。 通过这种方式，单个数据对象可以表示独立于程序其余部分发展的东西。 一个不断变化的对象的行为可能会受到它的历史的影响，就像世界上的一个实体一样。 向数据添加状态是称为面向对象编程的范式的核心组成部分。

### 2.4.1 对象隐喻

在本文的开头，我们区分了函数和数据：函数执行操作，数据被操作。 当我们在数据中包含函数值时，我们承认数据也可以有行为。 函数可以作为数据进行操作，但也可以被调用来执行计算。 

对象将数据值与行为结合起来。 对象代表信息，但也表现得像它们所代表的事物。 对象如何与其他对象交互的逻辑与编码对象值的信息捆绑在一起。 当一个对象被打印出来时，它知道如何在文本中拼写出来。 如果一个对象是由部件组成的，它知道如何根据需要显示这些部件。 对象既是信息又是过程，捆绑在一起表示复杂事物的属性、交互和行为。 

在Python中，对象行为是通过专门的对象语法和相关术语来实现的，我们可以通过示例介绍这些术语。 日期是一种对象。

```text
>>> from datetime import date
```

名称date被绑定到一个类。正如我们所看到的，类代表一种值。单独的日期被称为该类的实例。实例可以通过对实例的特征参数调用类来构造。

```text
>>> tues = date(2014, 5, 13)
```

虽然tues是由原始数字构造的，但它的行为与日期类似。例如，从另一个日期减去它将得到一个我们可以打印的时差。

```text
>>> print(date(2014, 5, 19) - tues)
6 days, 0:00:00
```

对象具有属性，这些属性是命名值，是对象的一部分。在Python中，像许多其他编程语言一样，我们使用点表示法来指定对象的属性。

```text
>>> tues.year
2014
```

对象也有方法，这些方法是函数值属性。打个比方，我们说对象“知道”如何执行这些方法。通过实现，方法是根据其参数和对象计算结果的函数。例如，tues的strftime方法\(一个经典的函数名称，意思是唤起“字符串格式的时间”\)只有一个参数，用来指定如何显示日期\(例如，% a表示应该完整地说出星期几\)。

```text
>>> tues.strftime('%A, %B %d')
'Tuesday, May 13'
```

计算strftime的返回值需要两个输入：描述输出格式的字符串和绑定成tues的日期信息。在此方法中应用特定日期的逻辑来产生此结果。 我们从未说过2014年5月13日是星期二，但知道相应的工作日是日期的一部分。 通过将行为和信息捆绑在一起，这个Python对象为我们提供了一个令人信服的、自包含的日期抽象。 

日期是对象，但是数字、字符串、列表和范围也是对象。 它们表示值，但也以适合它们所表示的值的方式行事。 它们还具有属性和方法。 例如，字符串有一个有助于文本处理的方法数组。

```text
>>> '1234'.isnumeric()
True
>>> 'rOBERT dE nIRO'.swapcase()
'Robert De Niro'
>>> 'eyes'.upper().endswith('YES')
True
```

事实上，Python中的所有值都是对象。也就是说，所有的值都有行为和属性。他们表现得像他们所代表的价值。

### 2.4.2 序列对象

原始内置值\(比如number\)的实例是不可变的。 这些值本身不能在程序执行过程中改变。 另一方面，列表是可变的。 可变对象用于表示随时间变化的值。 

一个人每天都是同一个人，尽管他变老了，剪了发，或者以其他方式改变了。 类似地，由于操作的变化，对象的属性也可能发生变化。 例如，可以更改列表的内容。 大多数更改是通过调用列表对象的方法来执行的。 

我们可以通过一个示例来介绍许多列表修改操作，该示例演示了扑克牌的历史\(大大简化了\)。 示例中的注释描述了每次方法调用的效果。 

扑克牌是在中国发明的，大约是在9世纪左右。 早期的一副牌有三套，分别对应不同面额的货币。

```text
>>> chinese = ['coin', 'string', 'myriad']  # A list literal
>>> suits = chinese                         # Two names refer to the same list
```

随着纸牌迁移到欧洲\(也许是通过埃及\)，西班牙的牌组\(oro\)中只剩下一套硬币。

```text
>>> suits.pop()             # Remove and return the final element
'myriad'
>>> suits.remove('string')  # Remove the first element that equals the argument
```

后来又增加了三套西装\(随着时间的推移，它们的名字和设计都有所变化\)，

```text
>>> suits.append('cup')              # Add an element to the end
>>> suits.extend(['sword', 'club'])  # Add all elements of a sequence to the end
```

意大利人把剑叫做铲子。

```text
>>> suits[2] = 'spade'  # Replace an element
```

给一副传统的意大利牌的套装

```text
>>> suits
['coin', 'cup', 'spade', 'club']
```

如今在美国使用的法语变体改变了前两种套装：

```text
>>> suits[0:2] = ['heart', 'diamond']  # Replace a slice
>>> suits
['heart', 'diamond', 'spade', 'club']
```

也存在插入、排序和反转列表的方法。所有这些突变操作都会改变列表的值;它们不创建新的列表对象。 

**共享和身份。**因为我们一直在更改单个列表而不是创建新的列表，绑定到名称chinese的对象也发生了变化，因为它是绑定到suits的同一个列表对象！

```text
>>> chinese  # This name co-refers with "suits" to the same changing list
['heart', 'diamond', 'spade', 'club']
```

这种行为是新的。以前，如果一个名称没有出现在语句中，那么它的值不会受到该语句的影响。对于可变数据，在一个名称上调用的方法可以同时影响另一个名称。 

[这个例子的环境图](http://composingprograms.com/tutor.html#code=chinese+%3D+%5B'coin',+'string',+'myriad'%5D%0Asuits+%3D+chinese%0Asuits.pop%28%29%0Asuits.remove%28'string'%29%0Asuits.append%28'cup'%29%0Asuits.extend%28%5B'sword',+'club'%5D%29%0Asuits%5B2%5D+%3D+'spade'%0Asuits%5B0%3A2%5D+%3D+%5B'heart',+'diamond'%5D)显示了绑定到chinese的值是如何被只涉及suits的语句更改的。通过下面示例中的每一行来观察这些变化。

![](../.gitbook/assets/image%20%2838%29.png)

可以使用list构造函数复制列表。对一个列表的更改不会影响另一个列表，除非它们共享结构。

```text
>>> nest = list(suits)  # Bind "nest" to a second list with the same elements
>>> nest[0] = suits     # Create a nested list
```

根据这个环境，更改suits引用的列表将影响nest的第一个元素的嵌套列表，而不会影响其他元素。

```text
>>> suits.insert(2, 'Joker')  # Insert an element at index 2, shifting the rest
>>> nest
[['heart', 'diamond', 'Joker', 'spade', 'club'], 'diamond', 'spade', 'club']
```

同样，撤消在nest的第一个元素中的更改也会更改suit。

```text
>>> nest[0].pop(2)
'Joker'
>>> suits
['heart', 'diamond', 'spade', 'club']
```

[逐行执行此示例](http://composingprograms.com/tutor.html#code=suits+%3D+%5B'heart',+'diamond',+'spade',+'club'%5D%0Anest+%3D+list%28suits%29%0Anest%5B0%5D+%3D+suits%0Asuits.insert%282,+'Joker'%29%0Ajoke+%3D+nest%5B0%5D.pop%282%29)将显示嵌套列表的表示方式。

![](../.gitbook/assets/image%20%2839%29.png)

因为两个列表可能有相同的内容，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否相同。Python包含两个名为is和is not的比较操作符，用于测试两个表达式是否实际计算为相同的对象。如果两个对象的当前值相等，则它们是相同的，对其中一个对象的任何更改都会在另一个对象中反映出来。身份是比平等更强的条件。

```text
>>> suits is nest[0]
True
>>> suits is ['heart', 'diamond', 'spade', 'club']
False
>>> suits == ['heart', 'diamond', 'spade', 'club']
True
```

最后两个比较说明了is和==之间的区别。前者检查身份，而后者检查内容的相等性。 

**列表推导式。**列表推导式总是创建一个新列表。例如，unicodedata模块跟踪Unicode字母表中每个字符的正式名称。我们可以查找与名字对应的字符，包括纸牌套对应的字符。

```text
>>> from unicodedata import lookup
>>> [lookup('WHITE ' + s.upper() + ' SUIT') for s in suits]
['♡', '♢', '♤', '♧']
```

这个结果列表不会与suits共享任何内容，并且对列表的推导式求值也不会修改suits列表。 

你可以在《深入Python 3》的Unicode部分阅读更多关于表示文本的Unicode标准的内容。 

**元组。**一个元组，一个内置元组类型的实例，是一个不可变序列。元组是用一个元组字面值创建的，该元组字面值用逗号分隔元素表达式。括号是可选的，但在实践中经常使用。任何对象都可以放在元组中。

```text
>>> 1, 2 + 3
(1, 5)
>>> ("the", 1, ("and", "only"))
('the', 1, ('and', 'only'))
>>> type( (10, 20) )
<class 'tuple'>
```

空元组和单元素元组具有特殊的文字语法。

```text
>>> ()    # 0 elements
()
>>> (10,) # 1 element
(10,)
```

与列表一样，元组具有有限的长度并支持元素选择。它们还有一些用于列表的方法，如count和index。

```text
>>> code = ("up", "up", "down", "down") + ("left", "right") * 2
>>> len(code)
8
>>> code[3]
'down'
>>> code.count("down")
2
>>> code.index("left")
4
```

然而，用于操作列表内容的方法对于元组是不可变的，所以是不可用的。 

虽然不可能更改元组中的哪些元素，但可以更改元组中包含的可变元素的值。

![](../.gitbook/assets/image%20%2836%29.png)

元组在多次赋值中被隐式使用。将两个值赋给两个名称将创建一个包含两个元素的元组，然后将其解包。



