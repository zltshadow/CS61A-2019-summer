# 2.3 序列

序列是值的有序集合。 序列是计算机科学中一个强大的、基本的抽象概念。 序列不是特定内置类型或抽象数据表示的实例，而是在几种不同类型的数据之间共享的行为集合。 也就是说，序列有很多种，但它们都有共同的行为。 特别是,

**长度。** 序列的长度是有限的。 空序列的长度为0。 

**元素的选择。** 序列有一个元素对应于任何小于其长度的非负整数索引，第一个元素从0开始。 

Python包括几种原生数据类型，它们是序列，其中最重要的是列表。

### 2.3.1 列表

列表值是可以具有任意长度的序列。列表有大量的内建行为，以及表达这些行为的特定语法。我们已经看到了计算结果为列表实例的列表字面量，以及计算结果为列表中的值的元素选择表达式。内置的len函数返回序列的长度。下面，digits是一个包含四个元素的列表。下标3的元素是8。

```text
>>> digits = [1, 8, 2, 8]
>>> len(digits)
4
>>> digits[3]
8
```

此外，列表可以相加并乘以整数。对于序列，加法和乘法并不添加或相乘元素，而是组合和复制序列本身。也就是说，operator模块中的add函数\(以及+操作符\)产生了一个连接所添加参数的列表。操作符中的mul函数\(和\*操作符\)可以接受一个列表和一个整数k，以返回由原始列表的k个重复组成的列表。

```text
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
```

任何值都可以包含在一个列表中，包括另一个列表。为了在包含列表的列表中选择深度嵌套的元素，可以多次应用元素选择。

```text
>>> pairs = [[10, 20], [30, 40]]
>>> pairs[1]
[30, 40]
>>> pairs[1][0]
30
```

### 2.3.2 序列迭代

在许多情况下，我们希望遍历序列的元素，并依次为每个元素执行一些计算。这种模式非常常见，因此Python有一个额外的控制语句来处理顺序数据：for语句。 

考虑计算一个值在序列中出现多少次的问题。我们可以使用while循环实现一个函数来计算这个计数。

```text
>>> def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total, index = 0, 0
        while index < len(s):
            if s[index] == value:
                total = total + 1
            index = index + 1
        return total
```

```text
>>> count(digits, 8)
2
```

Python for语句可以通过直接遍历元素值而根本不引入名称索引来简化函数体。

```text
>>> def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total = 0
        for elem in s:
            if elem == value:
                total = total + 1
        return total
```

```text
>>> count(digits, 8)
2
```

for语句由单个子句组成，其形式如下：

```text
for <name> in <expression>:
    <suite>
```

for语句由以下过程执行：

1. 求头文件&lt;表达式&gt;的值，它必须产生一个可迭代值。 
2. 对于该可迭代值中的每个元素值，按顺序：

   1. 在当前框架中绑定到该值。
   2. 执行&lt;套件&gt;。

这个执行过程引用可迭代值。 列表是序列的一种类型，而序列是可迭代值。 它们的元素按照它们的顺序来考虑。 Python还包括其他可迭代类型，但我们现在只关注序列; 术语“iterable”的一般定义出现在第4章的迭代器部分。 

这个评估程序的一个重要结果是：&lt;名称&gt;将在执行for语句后绑定到序列的最后一个元素。 for循环引入了另一种通过语句更新环境的方式。

**序列拆封。** 程序中的一种常见模式是，有一个本身是序列的元素序列，但所有元素的长度都固定。 for语句可以在其头文件中包含多个名称，以“解包”每个元素序列到其各自的元素中。 例如，我们可能有一个包含两元素列表的列表。

```text
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
```

并希望找到具有相同的第一个和第二个元素的对的数目。

```text
>>> same_count = 0
```

下面的for语句头中有两个名字，它将把每个名字x和y分别绑定到每对元素中的第一个和第二个元素。

```text
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
```

```text
>>> same_count
2
```

这种将多个名称绑定到固定长度序列中的多个值的模式称为序列解包;这与我们在赋值语句中看到的将多个名称绑定到多个值的模式相同。 

**范围。**range是Python中另一种内置的序列类型，它表示一个整数范围。使用range创建范围，range接受两个整数参数:第一个数字和所需范围内最后一个数字之外的一个。

```text
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)
```

在一个范围上调用list构造函数将计算出具有与该范围相同元素的列表，因此可以很容易地检查元素。

```text
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)
```

如果只给出了一个参数，则将其解释为从0开始的范围内超出最后一个值的参数。

```text
>>> list(range(5, 8))
[5, 6, 7]
```

Ranges通常以表达式的形式出现在for头文件中，以指定套件应该被执行的次数:通常的惯例是，如果名称在套件中未使用，则在for头文件中使用单个下划线字符：

```text
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

就解释器而言，这个下划线只是环境中的另一个名称，但在程序员中有一个常规的含义，表示这个名称不会出现在任何未来的表达式中。

### 2.3.3 序列处理

序列是一种非常常见的复合数据形式，整个程序通常都是围绕这个单一的抽象来组织的。 具有输入和输出序列的模块化组件可以混合和匹配来执行数据处理。 可以通过将序列处理操作的管道链接在一起来定义复杂的组件，每个操作都是简单且有重点的。 

**列表推导式。** 许多序列处理操作可以通过计算序列中每个元素的固定表达式并在结果序列中收集结果值来表示。 在Python中，列表推导式是执行此类计算的表达式。

```text
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

上面的for关键字不是for语句的一部分，而是列表推导式的一部分，因为它包含在方括号中。子表达式x+1在x绑定到每个概率元素的情况下依次求值，结果值被收集到一个列表中。 

另一个常见的序列处理操作是选择满足某些条件的值子集。列表推导式也可以表示这种模式，例如，选择平均除25的概率的所有元素。

```text
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

列表推导式的一般形式是：

```text
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

要对列表推导式求值，Python要对序列表达式求值，该表达式必须返回一个可迭代值。 然后，对于order中的每个元素，将元素值绑定到&lt;name&gt;，并计算过滤器表达式，如果它产生一个真值，则计算映射表达式。 映射表达式的值被收集到一个列表中。 

**聚合。** 序列处理中的第三种常见模式是将序列中的所有值聚合为单个值。 内置函数sum、min和max都是聚合函数的例子。

通过结合对每个元素求表达式、选择元素子集和聚合元素的模式，我们可以使用序列处理方法解决问题。 

完全数是一个等于它的因数之和的正整数。 n的除数是小于n的正整数，可以整除n。列出n的除数可以用列表推导式表示。

```text
>>> def divisors(n):
        return [1] + [x for x in range(2, n) if n % x == 0]
```

```text
>>> divisors(4)
[1, 2]
>>> divisors(12)
[1, 2, 3, 4, 6]
```

使用divisors，我们可以用另一个列表推导式计算从1到1000的所有完全数。\(1通常也被认为是一个完全数，但它不符合我们对除数的定义。\)

```text
>>> [n for n in range(1, 1000) if sum(divisors(n)) == n]
[6, 28, 496]
```

我们可以用除数的定义来解决另一个问题，求出边长为整数的矩形的最小周长，给定它的面积。矩形的面积是它的高乘以它的宽。因此，给定面积和高度，我们可以计算宽度。我们可以断言宽度和高度都平均地划分区域，以确保边长是整数。

```text
>>> def width(area, height):
        assert area % height == 0
        return area // height
```

矩形的周长是它边长的和。

```text
>>> def perimeter(width, height):
        return 2 * width + 2 * height
```

边长为整数的矩形的高度必须是其面积的除数。我们可以通过考虑所有高度来计算最小周长。

```text
>>> def minimum_perimeter(area):
        heights = divisors(area)
        perimeters = [perimeter(width(area, h), h) for h in heights]
        return min(perimeters)
```

```text
>>> area = 80
>>> width(area, 5)
16
>>> perimeter(16, 5)
42
>>> perimeter(10, 8)
36
>>> minimum_perimeter(area)
36
>>> [minimum_perimeter(n) for n in range(1, 10)]
[4, 6, 8, 8, 12, 10, 16, 12, 12]
```

**高阶函数。**我们在序列处理中观察到的常见模式可以用高阶函数来表示。首先，可以通过对每个元素应用函数来表示序列中每个元素的表达式。

```text
>>> def apply_to_all(map_fn, s):
        return [map_fn(x) for x in s]
```

只选择某个表达式为真的元素可以通过对每个元素应用函数来表示。

```text
>>> def keep_if(filter_fn, s):
        return [x for x in s if filter_fn(x)]
```

最后，许多形式的聚合可以表示为重复地对到目前为止的简化值和每个元素应用一个双参数函数。

```text
>>> def reduce(reduce_fn, s, initial):
        reduced = initial
        for x in s:
            reduced = reduce_fn(reduced, x)
        return reduced
```

例如，reduce可用于将序列中的所有元素相乘。使用mul作为reduce\_fn, 1作为初始值，reduce可以将一组数字相乘。

```text
>>> reduce(mul, [2, 4, 8], 1)
64
```

我们也可以用这些高阶函数找到完全数。

```text
>>> def divisors_of(n):
        divides_n = lambda x: n % x == 0
        return [1] + keep_if(divides_n, range(2, n))
```

```text
>>> divisors_of(12)
[1, 2, 3, 4, 6]
>>> from operator import add
>>> def sum_of_divisors(n):
        return reduce(add, divisors_of(n), 0)
```

```text
>>> def perfect(n):
        return sum_of_divisors(n) == n
```

```text
>>> keep_if(perfect, range(1, 1000))
[1, 6, 28, 496]
```

**传统的名字。**在计算机科学界，apply\_to\_all更常见的名称是map，而keep\_if更常见的名称是filter。在Python中，内置的map和filter是这些不返回列表的函数的泛化。这些函数将在第4章中讨论。上面的定义等价于对内置map和filter调用的结果应用list构造函数。

```text
>>> apply_to_all = lambda map_fn, s: list(map(map_fn, s))
>>> keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

reduce函数内置在Python标准库的functools模块中。在这个版本中，initial参数是可选的。

```text
>>> from functools import reduce
>>> from operator import mul
>>> def product(s):
        return reduce(mul, s)
```

```text
>>> product([1, 2, 3, 4, 5])
120
```

在Python程序中，直接使用列表推导式比使用高阶函数更常见，但这两种序列处理方法都被广泛使用。

### 2.3.4 序列的抽象

我们引入了满足序列抽象的两种原生数据类型：列表和范围。两者都满足本节开始时的条件：长度和元素选择。Python还包括两个序列类型的行为，它们扩展了序列抽象。 

**成员资格。**可以测试值是否属于序列。Python有两个操作符in和not in，根据元素是否出现在序列中，计算结果为True或False。

```text
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
```

**切片。**序列中包含更小的序列。序列的片是原始序列的任意连续空间，由一对整数指定。与range构造函数一样，第一个整数表示片的起始索引，第二个整数表示结束索引之后的整数。 

在Python中，序列切片的表达方式类似于元素选择，使用方括号。冒号分隔开始和结束索引。任何被省略的边界都被假定为一个极值:起始索引为0，结束索引为序列的长度。

```text
>>> digits[0:2]
[1, 8]
>>> digits[1:]
[8, 2, 8]
```

列举Python序列抽象的这些额外行为让我们有机会思考一般来说什么构成了有用的数据抽象。 抽象的丰富性\(即包含多少行为\)会产生结果。 对于抽象的用户，额外的行为是有帮助的。 另一方面，用新的数据类型来满足丰富抽象的需求可能很有挑战性。 丰富抽象的另一个负面后果是，用户需要花更长的时间来学习。 

序列具有丰富的抽象，因为它们在计算中无处不在，所以学习一些复杂的行为是合理的。 一般来说，大多数用户定义的抽象都应该尽可能地简单。 

**进一步阅读。** 切片表示法允许各种特殊情况，例如负的起始值、结束值和步长。 完整的描述出现在Dive Into Python 3中名为[切片列表](http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists)的小节中。 在本章中，我们将只使用上面描述的基本特性。





